// module bank::events {
//     use sui::coin::{Self, Coin};
//     use std::string::String;
//     use sui::dynamic_object_field as ofield;
//     use sui::object::{Self, ID, UID};
//     use sui::table::{Self, Table};
//     use sui::transfer;
//     use sui::tx_context::{Self, TxContext};
//     use std::type_name;
//     // use sui::event;

//     // Error Codes
//     const EZeroBalance: u64 = 0;
//     const ENotOwner: u64 = 1;
//     const ENoTreasury: u64 = 2;
//     const EInsufficientBalance: u64 = 3;

//     // Main Asset Bank Object
//     public struct AssetBank has key, store {
//         id: UID,
//         deposit_count: u64,
//         active_nfts: u64,
//     }

//     // Treasury for each coin type
//     public struct Treasury<phantom T> has key, store {
//         id: UID,
//         vault: Coin<T>,
//         balances: Table<address, u64>
//     }

//     // Non-transferable receipt (enforced via ownership checks)
//     public struct Receipt<phantom T> has key, store {
//         id: UID,
//         asset_bank_id: ID,
//         user: address,
//         amount: u64,
//         deposit_number: u64
//     }

//     // Events
//     public struct DepositEvent has copy, drop {
//         user: address,
//         amount: u64,
//         coin_type: String
//     }

//     public struct WithdrawEvent has copy, drop {
//         user: address,
//         amount: u64,
//         coin_type: String
//     }

//     // === Initialization ===
//     fun init(ctx: &mut TxContext) {
//         let asset_bank = AssetBank {
//             id: object::new(ctx),
//             deposit_count: 0,
//             active_nfts: 0
//         };
//         transfer::share_object(asset_bank);
//     }

//     // === Core Logic ===

//     // Deposit any coin type into the bank
//     public entry fun deposit<T: store>(
//         asset_bank: &mut AssetBank,
//         coin: Coin<T>,
//         ctx: &mut TxContext
//     ) {
//         let amount = coin::value(&coin);
//         assert!(amount > 0, EZeroBalance);

//         let type_name = type_name::get<T>();
//         let treasury_exists = ofield::exists_(&asset_bank.id, type_name);
        
//         if (!treasury_exists) {
//             let new_treasury = Treasury<T> {
//                 id: object::new(ctx),
//                 vault: coin::zero(ctx),
//                 balances: table::new(ctx)
//             };
//             ofield::add(asset_bank.id, type_name, new_treasury);
//         };

//         let treasury = ofield::borrow_mut<Treasury<T>>(asset_bank.id, type_name);
//         coin::join(&mut treasury.vault, coin);

//         let sender = tx_context::sender(ctx);
//         let balance = table::borrow_mut_with_default(&mut treasury.balances, sender, 0);
//         *balance = *balance + amount;

//         asset_bank.deposit_count = asset_bank.deposit_count + 1;
//         asset_bank.active_nfts = asset_bank.active_nfts + 1;
 
//         event::emit(DepositEvent {
//             user: sender,
//             amount,
//             coin_type: type_name
//         });

//         transfer::transfer(
//             Receipt<T> {
//                 id: object::new(ctx),
//                 asset_bank_id: object::id(asset_bank),
//                 user: sender,
//                 amount,
//                 deposit_number: asset_bank.deposit_count
//             },
//             sender
//         );
//     }

//     // Withdraw funds using receipt
//     public entry fun withdraw<T: store>(
//         asset_bank: &mut AssetBank,
//         receipt: Receipt<T>,
//         ctx: &mut TxContext
//     ) {
//         assert!(receipt.user == tx_context::sender(ctx), ENotOwner);

//         let type_name = type_name::get<T>();
//         assert!(ofield::exists_(asset_bank.id, type_name), ENoTreasury);
//         let treasury = ofield::borrow_mut<Treasury<T>>(asset_bank.id, type_name);

//         let balance = table::borrow_mut(&mut treasury.balances, receipt.user);
//         assert!(*balance >= receipt.amount, EInsufficientBalance);

//         let coins = coin::split(&mut treasury.vault, receipt.amount);
//         transfer::transfer(coins, receipt.user);

//         *balance = *balance - receipt.amount;
//         if (*balance == 0) {
//             table::remove(&mut treasury.balances, receipt.user);
//         };

//         asset_bank.active_nfts = asset_bank.active_nfts - 1;

//         event::emit(WithdrawEvent {
//             user: receipt.user,
//             amount: receipt.amount,
//             coin_type: type_name
//         });

//         let Receipt<T> { id, .. } = receipt;
//         object::delete(id);
//     }

//     // === View Functions ===
//     public fun get_deposit_count(asset_bank: &AssetBank): u64 {
//         asset_bank.deposit_count
//     }

//     public fun get_active_nfts(asset_bank: &AssetBank): u64 {
//         asset_bank.active_nfts
//     }
// }



    

