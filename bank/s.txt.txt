//https://yakitori.dev/blog/00-sui-move-for-solidity-devs/#object-ownership
#[allow(unused_use)]
module bank::bank {

    
    //standard libs
    use std::type_name::{Self, TypeName};
    use std::string::{Self, String};
    //standard sui libs
    use sui::event; //For Handling Events for NFT contract interaction
    use sui::balance::{Self, Balance};
    use sui::coin::{Self, Coin};
    use sui::object::{new};
    use sui::sui::SUI;
    //custom source libs
    use bank::ownership::{AdminCap, NFTOwnerCap}; //Ownership Models
    use bank::events::{Self, WithdrawEvent, DepositEvent}; //Custom Event Objects
    use bank::errors::{ge_zero_user_insufficient_funds}; //Custom Errors


 
    

    // use sui::balance::{Self, Balance}
    //Asset Bank for NFT TX Data
    //Add Copy Trait to clone, Drop Trait = drop to end lifetime at the EOO, Copy Trait = copy on OO, Key for Sui Global Storage Operations
    //UID - id structure with type address and key traitID - General ID, Note to self: drop and copy conflicts with key

    //Traits: 
    //key - so that AssetBank can be stored on chain
    //store - so that AssetBank can be stored in global storage
    //
    
    //Deposit Record - Helper Object
     //Helper Functiont that checks if coin type is allowed - ENUMS and MATCH is causing errors
    // public fun coin_type_is_allowed(coin_type: AllowedCoinTypes): String {
    //     match (coin_type){
    //         AllowedCoinTypes::USDC => string::uft8(b"USDC"), //USDC in String
    //         AllowedCoinTypes::USDT => string::uft8(b"USDT"), //USDT is String
    //         AllowedCoinTypes::SUI => string::uft8(b"SUI"), //SUI is String
    //         _ => std::string::uft8(b"NOTALLOWED") //NOTALLOWED is String
            
    //     }
    // }

    //Coin Type Constants 
    const USDC: vector<u8> = b"USDC";
    const USDT: vector<u8> = b"USDT";
    const SUI: vector<u8> = b"SUI";
    //Enum of Allowed Coin Types
    public enum AllowedCoinTypes has drop {
        USDC,
        USDT,
        SUI
    }
   

      public struct CoinValueObject<T> has store {
        coin_type: T, 
        amount: u64
      }
      public struct DepositRecordObject<T> has store {
        key: address,
        value: CoinValueObject<T>
    }

    fun create_record_vector<T>(): vector<DepositRecordObject<T>> {
        vector::empty<DepositRecordObject<T>>()
    }
    

    //AssetBank Object
    public struct AssetBank has key, store {
        id: UID, //UID for AssetBank Unique 
        deposit_count: u64, //For tracking number of deposits to the bank
        number_of_active_nfts: u64, //For current of nft deposited in
        admin: address, //Admin of the Asset Bank Object
        deposits: vector<DepositRecordObject<T>>, //Store all the deposit receipts
        total_balance: u64
    }
    // Asset Bank Initialisation Event 
    public struct AssetBankInitEvent has copy, drop {
        asset_bank_id: ID,
        creator: address,
        deposit_count: u64,
        nft_count: u64,
    }
    // Public View Functions Interfaces for On-Chain Asset Bank Interactions
    public fun get_deposit_count<T>(bank: &AssetBank): &u64 {
        &bank.deposit_count
    }
    public fun get_number_of_active_nfts<T>(bank: &AssetBank): &u64 {
        &bank.number_of_active_nfts
    }

    public fun get_admin<T>(bank: &AssetBank): &address {
        &bank.admin
    }

    public fun get_receipts<T>(bank: &AssetBank): &vector<DepositRecordObject> {
        &bank.deposits
    }

     //NFT Receipt Object 
    public struct Receipt<T> has key, store {
        id: UID, //Global SUI ID 
        nft_count: u64, //NFT count value
        address_of_depositor: address, //Address of the Coin Depositor
        amount_deposited: u64, //Amount of tokens deposited
        coin_type: Coin<T>
    }


      //Deposit Functionaility 
      public fun deposit<T>(bank: &mut AssetBank<T>, coin: Coin<T>, ctx: &mut TxContext): Coin<T>{

        //1. Revert if the balance of the provided coin object is ZERO
        //Coin struct has two props, id and balance only need the balance right now
        let coin_amount = coin.value(); //returns self.balance.value()
        if(coin_amount == 0){
            //If balance is zero we abort the process
            abort bank::errors::ge_zero_user_insufficient_funds();
        };

       //2. Take the user coin and deposit in the bank object
       //keep track of coin and depositor Vec of deposit objects
        //According to the challenge T is Coin Typ
        let coin_type_name = type_name::get<T>(); //Get Parameter name as Typename Struct at runtime (at deployment)
        let coin_type_name_as_string = std::type_name::into_string(coin_type_name); //Extracting the TypeName Struct String as vector<u8>
        
        //MATCH EXPRESSIONS ARE NOT WORKING SO ALTERNATIVE
        if(!(coin_type_name_as_string == b"USDC" || coin_type_name_as_string == b"USDT" || coin_type_name_as_string == b"SUI")) { 
                abort bank::errors::ge_coin_type_not_allowed();
            }; 
        

        //Create User Deposit Record Vector - Shape: key: address, value {coin_type, amount} 
        let userObject = DepositRecordObject { key: ctx.sender(), value: CoinValueObject {coin_type: T, amount: coin_amount} };

       //Check if call has already deposited already first - assuming one nft deposit per user max
       //1st ARG: Take reference to depositor Vector of type DepositRecordVector
       //2nd ARG: Take reference to the userObject composed from the function caller and balance
        let alreadyExists = vector::contains<DepositRecordObject<T>>(&bank.deposits, &userObject);
        if(alreadyExists){
        //Looking for existing users address based on the Deposit Object by their address
        //If the user already exists we abort 
            abort bank::errors::ge_user_already_deposited_nft();
        };
            //Push the user Object to the bank deposits vector
            //&vector<bank::bank::DepositRecordObject>
          
        vector::push_back<DepositRecordObject>(&mut bank.deposits, userObject);
        //Extract user coin balance and add it the asset bank balance

        //using into_balance method to ensure coin is consumed
        let coin_balance = sui::coin::into_balance(coin); //Take coin and covert it to balance
        let balance = sui::balance::value(&coin_balance); //Extract value as a u64 from coin balance
            
        //Consume the coin 
        //3. Increase the number of deposits
        //4. Increase the number of active NFTs
        //5. Increase the total balance of the asset bank
        bank.deposit_count = bank.deposit_count + 1; //Update deposit count state
        bank.number_of_active_nfts = bank.number_of_active_nfts + 1; //Update active NFT state
        bank.total_balance = bank.total_balance + balance; //Update total balance
        
        
            //6. Emit an appropraite deposit event
            //emit_deposit_event
            //1. 1st arg - deposit_amount as u64
            //2. 2nd arg - transaction senders address
           
        bank::events::emit_deposit_event(balance, ctx.sender());


        //7. Transfer NFT - Call internal create NFT Function
        // let deposited_type = 

        }
  
     
//Expose public method to withdraw funds by returning minted NFT
    public entry fun withdraw<T>(_: &TxContext, bank: &mut AssetBank, receipt: Receipt<T>){
        //UPDATE - On reviewing the caller of the function needs to verified before state management
        //NOTE the sui::object module doesn't contain a direct way to find the call of the function
        //So I've added a third param ctx to get the transaction context object to get the caller
        
     

        //1. Get Contract caller and receipt info
        //Here I am grabbing the contract call to assert if caller of withdraw has a deposit in the AssetBank
        let address_of_depositor = tx_context::sender(ctx);
        //user_entry = cross checks for nft_receipt number of nft receipt holder with asset bank nft record in the bag
        let user = dynamic_field::exists_<u64>(&receipt.id, receipt.nft_receipt_number);
        assert!(user, bank::errors::ge_unauthorised_user_acccess()); //Error raised if contract caller is not the depositor address

        //2. Check if contract caller's address matches the address_of_depositor
        assert!(receipt.address_of_depositor == address_of_depositor, 1010);

        //3. Check if the NFT receipt is claimed by a user already
        assert!(!receipt.claimed, 1011); 

        //3b. Since we need to provide the balance the user deposit 
        //   I'm checking the Asset Bank Balance Bag (key-value object)
        let asset_bank_balance = dynamic_field::exists_<T>(&mut bank.id);
        //Raises assert exception if balance is not sufficient
        assert!(!asset_bank_balance, 1012);
        //Extract the balance as mut reference
        let balance = dynamic_field::borrow_mut<T, Balance<T>>(&mut bank.id, T); //Returns (id and value)
        //Raises assert exception if balance in asset bank is not enough for the receipt.amount
        assert!(balance::value(balance) >= receipt.amount, 1013);
    
        //If the asset bank has enough balance ( which is should :)...abort
        //Then we can extract the balance and covert it to a transferable coin
        let coin = sui::coin::from_balance(balance::split(balance, receipt.amount), ctx);
        //Then transfer the coin from the balance to the function call (depositor)
        transfer::transfer(coin, address_of_depositor);


      
        //To handle to the prevention of a reentrancy attack (double spend)
        //mut by value for receipt
        let mut mut_receipt = receipt;
        //Access the claimed prop and change the actual value not the ref value (copied)
        mut_receipt.claimed = true; // Mark nft receipt as used now
        //Here I've replaced by value the receipt object with key receipt number for the old entry
        dynamic_field::add(&mut bank.id, receipt.nft_receipt_number, mut_receipt);


        //4. Update the state of current nfts
        //Here I'm not do anything to the state of receipts count only active nfts 
        //nfts count be balanced asset bank other wise we go broke :)
        bank.number_of_current_nfts = bank.number_of_current_nfts - 1;

        //5. Destroy the receipt (NFT receipt object)
        object::delete(receipt.id);

        //6. Emit an appropriate withdrawal event
        //Note to self - Withdraw needs the copy trait (event types) (run testing)
        event::emit(WithdrawEvent {
        nft_receipt_number: receipt.nft_receipt_number, //NFT Receipt number that is consumed
        amount: receipt.amount,//Amount transfer to the rightful user (depositor)
        address_of_depositor: address_of_depositor, //Address of depositor
        });

    }

    
    //Bank Contract Constructor Function
    //On initialisation creates an AssetBank as shared global object that user can interact with
    fun init<T>(ctx: &mut TxContext) {
        let sender = ctx.sender();
        let asset_bank = AssetBank<T> {
            id: object::new(ctx), //Assign UID to register on Sui
            deposit_count: 0,//Initial Deposit State is 0 on deployment
            number_of_active_nfts: 0,//Initial NFT Count state is 0 on deployment
            admin: tx_context::sender(ctx), //Contract Initialiser -> Admin 
            deposits: create_record_vector<T>(),
            total_balance: 0
        };

        
        //Emit an event for the creation of the AssetBank
        event::emit(AssetBankInitEvent {
            asset_bank_id: object::id(&asset_bank),
            creator: sender, //Initialisor of the AssetBank Contract
            deposit_count: asset_bank.deposit_count, //Immutable ref to assetbanks initial deposit count
            nft_count: asset_bank.number_of_active_nfts,    
        });

        //On creation transfer the object
        transfer::share_object(asset_bank)

    }

  
}
  